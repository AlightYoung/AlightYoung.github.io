(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{433:function(t,a,s){"use strict";s.r(a);var n=s(2),r=Object(n.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"synchronized-关键字"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#synchronized-关键字"}},[t._v("#")]),t._v(" Synchronized 关键字")]),t._v(" "),a("p",[t._v("Java语言的关键字，可用来给对象和方法或者代码块加锁，当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行这段代码。当两个并发线程访问同一个对象object中的这个加锁同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。然而，当一个线程访问object的一个加锁代码块时，另一个线程仍可以访问该object中的非加锁代码块。")]),t._v(" "),a("h4",{attrs:{id:"同步方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#同步方法"}},[t._v("#")]),t._v(" 同步方法")]),t._v(" "),a("p",[a("code",[t._v("synchronized T methodName(){}")]),t._v("同步方法锁定的是当前对象。当多线程通过同一个对象引用多次调用当前同步方法时，需同步执行。")]),t._v(" "),a("h4",{attrs:{id:"同步代码块"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#同步代码块"}},[t._v("#")]),t._v(" 同步代码块")]),t._v(" "),a("p",[t._v("同步代码块的同步粒度更加细致，是实际开发中推荐的编程方式。可以定位到具体的同步位置，而不是简单的将方法整体实现同步逻辑。在效率上，相对更高。")]),t._v(" "),a("h5",{attrs:{id:"锁定临界对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#锁定临界对象"}},[t._v("#")]),t._v(" 锁定临界对象")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("methodName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("object"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])]),a("p",[t._v("同步代码块在执行时，是锁定 object 对象。当多个线程调用同一个方法时，锁定对象不变的情况下，需同步执行。")]),t._v(" "),a("h5",{attrs:{id:"锁定当前对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#锁定当前对象"}},[t._v("#")]),t._v(" 锁定当前对象")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("methodName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("     \n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])]),a("p",[t._v("当锁定对象为 this 时，相当于调用"),a("code",[t._v("synchronized T methodName(){}")]),t._v("同步方法。")]),t._v(" "),a("h4",{attrs:{id:"锁的底层实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#锁的底层实现"}},[t._v("#")]),t._v(" 锁的底层实现")]),t._v(" "),a("p",[t._v("Java 虚拟机中的同步(Synchronization)基于进入和退出管程(Monitor)对象实现。同步方法 并不是由 monitor enter 和 monitor exit 指令来实现同步的，而是由方法调用指令读取运行时常量池中方法的 ACC_SYNCHRONIZED 标志来隐式实现的。")]),t._v(" "),a("h5",{attrs:{id:"对象内存简图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象内存简图"}},[t._v("#")]),t._v(" 对象内存简图")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://alightyoung.gitee.io/static/img/33.webp",alt:"img"}})]),t._v(" "),a("p",[a("strong",[t._v("对象头")]),t._v(":存储对象的 hashCode、锁信息或分代年龄或 GC 标志，类型指针指向对象的类\n"),a("strong",[t._v("元数据")]),t._v(":JVM 通过这个指针确定该对象是哪个类的实例等信息。\n"),a("strong",[t._v("实例变量")]),t._v("：存放类的属性数据信息，包括父类的属性信息\n"),a("strong",[t._v("填充数据")]),t._v("：由于虚拟机要求对象起始地址必须是 8 字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐")]),t._v(" "),a("p",[t._v("当在对象上加锁时，数据是记录在对象头中。当执行 synchronized 同步方法或同步代码块时，会在对象头中记录锁标记，锁标记指向的是 monitor 对象（也称为管程或监视器锁）的起始地址。每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如 monitor 可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。")]),t._v(" "),a("p",[t._v("在 Java 虚拟机(HotSpot)中，monitor 是由 ObjectMonitor 实现的。ObjectMonitor 中有两个队列，_WaitSet 和 _EntryList，以及_Owner 标记。其中_WaitSet是用于管理等待队列(wait)线程的，_EntryList 是用于管理锁池阻塞线程的，_Owner 标记用于记录当前执行线程。线程状态图如下：\n"),a("img",{attrs:{src:"https://alightyoung.gitee.io/static/img/34.png",alt:"img"}})]),t._v(" "),a("h4",{attrs:{id:"锁的种类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#锁的种类"}},[t._v("#")]),t._v(" 锁的种类")]),t._v(" "),a("p",[t._v("Java 中锁的种类大致分为偏向锁，锁的自旋，轻量级锁，重量级锁。")]),t._v(" "),a("p",[t._v("锁的使用方式为：先提供偏向锁，如果不满足的时候，升级为轻量级锁，再不满足，升级为重量级锁。*自旋锁是一个过渡的锁状态，不是一种实际的锁类型。*锁只能升级，不能降级。")]),t._v(" "),a("h5",{attrs:{id:"重量级锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重量级锁"}},[t._v("#")]),t._v(" 重量级锁")]),t._v(" "),a("p",[t._v("内置锁在Java中被抽象为监视器锁（monitor）。")]),t._v(" "),a("p",[t._v("在JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。这种同步方式的成本非常高，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。因此，后来称这种锁为“重量级锁”。也就是上面说的锁的底层。")]),t._v(" "),a("h5",{attrs:{id:"偏向锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#偏向锁"}},[t._v("#")]),t._v(" 偏向锁")]),t._v(" "),a("p",[t._v("偏向锁是一种编译解释锁。")]),t._v(" "),a("p",[t._v("如果代码中不可能出现多线程并发争抢同一个锁的时候，JVM 编译代码，解释执行的时候，会自动的放弃同步信息。消除 synchronized 的同步代码结果。使用锁标记的形式记录锁状态。在 Monitor 中有变量 ACC_SYNCHRONIZED。当变量值使用的时候，代表偏向锁锁定。可以避免锁的争抢和锁池状态的维护。提高效率。")]),t._v(" "),a("h5",{attrs:{id:"轻量级锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#轻量级锁"}},[t._v("#")]),t._v(" 轻量级锁")]),t._v(" "),a("p",[t._v("过渡锁。")]),t._v(" "),a("p",[t._v("当偏向锁不满足，也就是有多线程并发访问，锁定同一个对象的时候，先提升为轻量级锁。也是使用标记 ACC_SYNCHRONIZED 标记记录的。ACC_UNSYNCHRONIZED 标记记录未获取到锁信息的线程。就是只有两个线程争抢锁标记的时候，优先使用轻量级锁。两个线程也可能出现重量级锁。")]),t._v(" "),a("h5",{attrs:{id:"自旋锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自旋锁"}},[t._v("#")]),t._v(" 自旋锁")]),t._v(" "),a("p",[t._v("自旋锁是一个过渡锁，是偏向锁和轻量级锁的过渡。")]),t._v(" "),a("p",[t._v("当获取锁的过程中，未获取到。为了提高效率，JVM 自动执行若干次空循环，再次申请锁，而不是进入阻塞状态的情况。称为自旋锁。自旋锁提高效率就是避免线程状态的变更。")]),t._v(" "),a("h3",{attrs:{id:"volatile-关键字"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#volatile-关键字"}},[t._v("#")]),t._v(" Volatile 关键字")]),t._v(" "),a("p",[t._v("变量的线程可见性。在 CPU 计算过程中，会将计算过程需要的数据加载到 CPU 计算缓存中，当 CPU 计算中断时，有可能刷新缓存，重新读取内存中的数据。在线程运行的过程中，如果某变量被其他线程修改，可能造成数据不一致的情况，从而导致结果错误。而 volatile修饰的变量是线程可见的，当 JVM 解释 volatile 修饰的变量时，会通知 CPU，在计算过程中，每次使用变量参与计算时，都会检查内存中的数据是否发生变化，而不是一直使用 CPU 缓存中的数据，可以保证计算结果的正确。volatile 只是通知底层计算时，CPU 检查内存数据，而不是让一个变量在多个线程中同步。")]),t._v(" "),a("h3",{attrs:{id:"wait-notify"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#wait-notify"}},[t._v("#")]),t._v(" wait&notify")]),t._v(" "),a("p",[t._v("在Object对象中有三个方法wait()、notify()、notifyAll()，它们的用途都是用来控制线程的状态。")]),t._v(" "),a("h4",{attrs:{id:"wait"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#wait"}},[t._v("#")]),t._v(" wait()")]),t._v(" "),a("p",[t._v("该方法用来将当前线程置入休眠状态，直到在其他线程调用此对象的notify()方法或notifyAll()方法将其唤醒。")]),t._v(" "),a("p",[t._v("在调用wait()之前，线程必须要获得该对象的对象级别锁，因此只能在同步方法或同步块中调用wait()方法。进入wait()方法后，当前线程释放锁。在从wait()返回前，线程与其他线程竞争重新获得锁。如果调用wait()时，没有持有适当的锁，则抛出IllegalMonitorStateException，它是RuntimeException的一个子类，因此，不需要try-catch结构。")]),t._v(" "),a("h4",{attrs:{id:"notify"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#notify"}},[t._v("#")]),t._v(" notify()")]),t._v(" "),a("p",[t._v("该方法唤醒在此对象监视器上等待的单个线程。如果有多个线程都在此对象上等待，则会"),a("strong",[t._v("随机选择")]),t._v("唤醒其中一个线程，对其发出通知notify()，并使它等待获取该对象的对象锁。注意“等待获取该对象的对象锁”，这意味着，即使收到了通知，wait的线程也不会马上获取对象锁，必须等待notify()方法的线程释放锁才可以。和wait()一样，notify()也要在同步方法/同步代码块中调用。")]),t._v(" "),a("h4",{attrs:{id:"notifyall"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#notifyall"}},[t._v("#")]),t._v(" notifyAll()")]),t._v(" "),a("p",[t._v("notifyAll()的作用是唤醒在此对象监视器上等待的"),a("strong",[t._v("所有线程")]),t._v("。其用法与notify()基本一致，只不过它会唤醒一个对象监视器上等待的全部线程，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；")]),t._v(" "),a("h4",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("p",[t._v("wait()使线程停止运行，notify()/notifyAll()使停止运行的线程继续运行。")]),t._v(" "),a("h3",{attrs:{id:"atomicxxx-类型组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#atomicxxx-类型组"}},[t._v("#")]),t._v(" AtomicXxx 类型组")]),t._v(" "),a("p",[t._v("原子类型。")]),t._v(" "),a("p",[t._v("在 concurrent.atomic 包中定义了若干原子类型，这些类型中的每个方法都是保证了原子操作的。多线程并发访问原子类型对象中的方法，不会出现数据错误。在多线程开发中，如果某数据需要多个线程同时操作，且要求计算原子性，可以考虑使用原子类型对象。")]),t._v(" "),a("blockquote",[a("p",[t._v("注意：原子类型中的方法是保证了原子操作，但多个方法之间是没有原子性的。如：\nAtomicInteger i = new AtomicInteger(0);\nif(i.get() != 5) i.incrementAndGet();\n在上述代码中，get 方法和 incrementAndGet 方法都是原子操作，但复合使用时，无法\n保证原子性，仍旧可能出现数据错误。")])]),t._v(" "),a("h3",{attrs:{id:"countdownlatch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#countdownlatch"}},[t._v("#")]),t._v(" CountDownLatch")]),t._v(" "),a("p",[t._v("CountDownLatch是 concurrent 包中定义的一个类型，是用于多线程通讯的一个辅助类型。")]),t._v(" "),a("p",[t._v("CountDownLatch相当于在一个门上加多个锁，当线程调用 await 方法时，会检查CountDownLatch数量，如果CountDownLatch数量大于 0，线程会阻塞等待。当线程调用 countDown 时，会递减CountDownLatch的数量，当CountDownLatch数量为 0 时，await 阻塞线程可执行。")]),t._v(" "),a("h3",{attrs:{id:"锁的重入"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#锁的重入"}},[t._v("#")]),t._v(" 锁的重入")]),t._v(" "),a("p",[t._v("在 Java 中，同步锁是可以重入的。只有同一线程调用同步方法或执行同步代码块，对同一个对象加锁时才可重入。")]),t._v(" "),a("p",[t._v("当线程持有锁时，会在 monitor 的计数器中执行递增计算，若当前线程调用其他同步代码，且同步代码的锁对象相同时，monitor 中的计数器继续递增。每个同步代码执行结束，monitor 中的计数器都会递减，直至所有同步代码执行结束，monitor 中的计数器为 0 时，释放锁标记，_Owner 标记赋值为 null。")]),t._v(" "),a("h3",{attrs:{id:"reentrantlock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reentrantlock"}},[t._v("#")]),t._v(" ReentrantLock")]),t._v(" "),a("p",[t._v("重入锁，建议应用的同步方式。相对效率比 synchronized 高。量级较轻。")]),t._v(" "),a("p",[t._v("synchronized 在 JDK1.5 版本开始，尝试优化。到 JDK1.7 版本后，优化效率已经非常好了。在绝对效率上，已经和reentrantLock差不多了。但ReentrantLock相比synchronized而言功能更加丰富，使用起来更为灵活，也更适合复杂的并发场景。")]),t._v(" "),a("p",[t._v("使用重入锁，必须必须必须手工释放锁标记。一般都是在 finally 代码块中定义释放锁标记的 unlock 方法。")]),t._v(" "),a("h3",{attrs:{id:"公平-非公平锁-乐观-非乐观锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#公平-非公平锁-乐观-非乐观锁"}},[t._v("#")]),t._v(" 公平/非公平锁 & 乐观/非乐观锁")]),t._v(" "),a("h4",{attrs:{id:"公平锁-非公平锁-多线程执行顺序的维度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#公平锁-非公平锁-多线程执行顺序的维度"}},[t._v("#")]),t._v(" 公平锁/非公平锁（多线程执行顺序的维度）")]),t._v(" "),a("p",[a("strong",[t._v("概念理解")])]),t._v(" "),a("ul",[a("li",[t._v("公平锁：加锁前先查看是否有排队等待的线程，有的话优先处理排在前面的线程，先来先得。")]),t._v(" "),a("li",[t._v("非公平所：线程加锁时直接尝试获取锁，获取不到就自动到队尾等待。")])]),t._v(" "),a("p",[a("strong",[t._v("例子：")])]),t._v(" "),a("ul",[a("li",[t._v("ReentrantLock 同时支持两种锁")])]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//创建一个非公平锁，默认是非公平锁")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Lock")]),t._v(" nonFairLock"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReentrantLock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Lock")]),t._v(" nonFairLock"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReentrantLock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//创建一个公平锁，构造传参true")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Lock")]),t._v(" fairLock"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReentrantLock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br")])]),a("p",[a("strong",[t._v("适用场景：")])]),t._v(" "),a("p",[t._v("更多的是直接使用非公平锁：非公平锁比公平锁性能高5-10倍，因为公平锁需要在多核情况下维护一个队列，如果当前线程不是队列的第一个无法获取锁，增加了线程切换次数。")]),t._v(" "),a("h4",{attrs:{id:"乐观锁-悲观锁-多线程操作共享数据的维度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#乐观锁-悲观锁-多线程操作共享数据的维度"}},[t._v("#")]),t._v(" 乐观锁/悲观锁（多线程操作共享数据的维度）")]),t._v(" "),a("p",[a("strong",[t._v("概念理解")])]),t._v(" "),a("ul",[a("li",[t._v("悲观锁：假设一定会发生并发冲突，通过阻塞其他所有线程来保证数据的完整性。")]),t._v(" "),a("li",[t._v("乐观锁：假设不会发生并发冲突，直接不加锁去完成某项更新，如果冲突就返回失败。")])]),t._v(" "),a("p",[a("strong",[t._v("例子")])]),t._v(" "),a("ul",[a("li",[t._v("悲观锁：Synchronized多线程同步，具有排他性，也会容易产生死锁。")]),t._v(" "),a("li",[t._v("乐观锁：CAS机制，简单来说会有三个操作数，当前内存变量值V，变量预期值A，即将更新值B，当需要更新变量的时候，会直接将变量值V和预期值A进行比较，如果相同，则直接更新为B；如果不相同，则当前变量值V刷新到预期值中，然后重新尝试比较更新。")])]),t._v(" "),a("p",[a("strong",[t._v("适用场景")])]),t._v(" "),a("ul",[a("li",[t._v("乐观锁：适用于数据争用不严重/重试代价不大/需要相应速度快的场景。")]),t._v(" "),a("li",[t._v("悲观锁：适用于数据争用严重/重试代价大的场景。")])]),t._v(" "),a("h3",{attrs:{id:"threadlocal"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal"}},[t._v("#")]),t._v(" ThreadLocal")]),t._v(" "),a("p",[t._v("早在JDK 1.2的版本中就提供java.lang.ThreadLocal，ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。")]),t._v(" "),a("p",[t._v("当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。")]),t._v(" "),a("p",[t._v("从线程的角度看，目标变量就象是线程的本地变量，这也是类名中“Local”所要表达的意思。")]),t._v(" "),a("p",[t._v("所以，在Java中编写线程局部变量的代码相对来说要笨拙一些，因此造成线程局部变量没有在Java开发者中得到很好的普及。")]),t._v(" "),a("h4",{attrs:{id:"thread同步机制的比较"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#thread同步机制的比较"}},[t._v("#")]),t._v(" Thread同步机制的比较")]),t._v(" "),a("p",[t._v("在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。")]),t._v(" "),a("p",[t._v("而ThreadLocal则从另一个角度来解决多线程的并发访问。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。")]),t._v(" "),a("p",[t._v("概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。")])])}),[],!1,null,null,null);a.default=r.exports}}]);
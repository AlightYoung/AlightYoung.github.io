(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{435:function(e,t,a){"use strict";a.r(t);var r=a(2),s=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h3",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),t("p",[e._v("Java为了解决并发情况下的容器线程安全问题的,给多线程环境准备一个线程安全的容器对象。线程安全的容器对象： Vector, Hashtable。线程安全容器对象，都是使用 synchronized方法实现的。而concurrent 包中的同步容器，大多数是使用系统底层技术实现的线程安全。类似 native。Java8 中使用 CAS。")]),e._v(" "),t("p",[e._v("以下是一些较为常见的并发容器")]),e._v(" "),t("h3",{attrs:{id:"map-set"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#map-set"}},[e._v("#")]),e._v(" Map/Set")]),e._v(" "),t("h4",{attrs:{id:"concurrenthashmap-concurrenthashset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap-concurrenthashset"}},[e._v("#")]),e._v(" ConcurrentHashMap/ConcurrentHashSet")]),e._v(" "),t("p",[e._v("底层哈希实现的同步 Map(Set)。效率高，线程安全。使用系统底层技术实现线程安全。量级较 synchronized 低。key 和 value 不能为 null。")]),e._v(" "),t("h4",{attrs:{id:"concurrentskiplistmap-concurrentskiplistset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#concurrentskiplistmap-concurrentskiplistset"}},[e._v("#")]),e._v(" ConcurrentSkipListMap/ConcurrentSkipListSet")]),e._v(" "),t("p",[e._v("底层跳表（SkipList）实现的同步 Map(Set)。有序，效率比 ConcurrentHashMap 稍低。")]),e._v(" "),t("blockquote",[t("p",[t("a",{attrs:{href:"https://baike.baidu.com/item/%E8%B7%B3%E8%A1%A8/22819833?fr=aladdin",target:"_blank",rel:"noopener noreferrer"}},[e._v("SkipList"),t("OutboundLink")],1)])]),e._v(" "),t("h3",{attrs:{id:"list"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#list"}},[e._v("#")]),e._v(" List")]),e._v(" "),t("h4",{attrs:{id:"copyonwritearraylist"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#copyonwritearraylist"}},[e._v("#")]),e._v(" CopyOnWriteArrayList")]),e._v(" "),t("p",[e._v("写时复制集合。写入效率低，读取效率高。每次写入数据，都会创建一个新的底层数组。")]),e._v(" "),t("h3",{attrs:{id:"queue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#queue"}},[e._v("#")]),e._v(" Queue")]),e._v(" "),t("h4",{attrs:{id:"concurrentlinkedqueue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#concurrentlinkedqueue"}},[e._v("#")]),e._v(" ConcurrentLinkedQueue")]),e._v(" "),t("p",[e._v("基础链表同步队列。")]),e._v(" "),t("h4",{attrs:{id:"linkedblockingqueue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linkedblockingqueue"}},[e._v("#")]),e._v(" LinkedBlockingQueue")]),e._v(" "),t("p",[e._v("阻塞队列，队列容量不足自动阻塞，队列容量为 0 自动阻塞。")]),e._v(" "),t("h4",{attrs:{id:"arrayblockingqueue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#arrayblockingqueue"}},[e._v("#")]),e._v(" ArrayBlockingQueue")]),e._v(" "),t("p",[e._v("底层数组实现的有界队列。自动阻塞。根据调用 API（add/put/offer）不同，有不同特性。当容量不足的时候，有阻塞能力。")]),e._v(" "),t("p",[e._v("add 方法在容量不足的时候，抛出异常。")]),e._v(" "),t("p",[e._v("put 方法在容量不足的时候，阻塞等待。")]),e._v(" "),t("p",[e._v("offer 方法，单参数 offer 方法，不阻塞。容量不足的时候，返回 false。当前新增数据操作放弃。三参数 offer 方法（offer(value,times,timeunit)），容量不足的时候，阻塞 times 时长（单位为 timeunit），如果在阻塞时长内，有容量空闲，新增数据返回 true。如果阻塞时长范围内，无容量空闲，放弃新增数据，返回 false。")]),e._v(" "),t("h4",{attrs:{id:"delayqueue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#delayqueue"}},[e._v("#")]),e._v(" DelayQueue")]),e._v(" "),t("p",[e._v("延时队列。根据比较机制，实现自定义处理顺序的队列。常用于定时任务。如：定时关机。")]),e._v(" "),t("h4",{attrs:{id:"linkedtransferqueue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linkedtransferqueue"}},[e._v("#")]),e._v(" LinkedTransferQueue")]),e._v(" "),t("p",[e._v("转移队列，使用 transfer 方法，实现数据的即时处理。没有消费者，就阻塞。")]),e._v(" "),t("h4",{attrs:{id:"synchronusqueue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#synchronusqueue"}},[e._v("#")]),e._v(" SynchronusQueue")]),e._v(" "),t("p",[e._v("同步队列，是一个容量为 0 的队列。是一个特殊的 TransferQueue。必须现有消费线程等待，才能使用的队列。\nadd 方法，无阻塞。若没有消费线程阻塞等待数据，则抛出异常。\nput 方法，有阻塞。若没有消费线程阻塞等待数据，则阻塞。")]),e._v(" "),t("h3",{attrs:{id:"最后"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最后"}},[e._v("#")]),e._v(" 最后")]),e._v(" "),t("p",[e._v("这里只是简单的记录一下并发容器，以后了解了再填坑。。。")])])}),[],!1,null,null,null);t.default=s.exports}}]);
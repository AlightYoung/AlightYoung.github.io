(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{440:function(t,a,v){"use strict";v.r(a);var e=v(2),_=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("hr"),t._v(" "),a("h3",{attrs:{id:"网络编程-socket-概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#网络编程-socket-概念"}},[t._v("#")]),t._v(" 网络编程（Socket）概念")]),t._v(" "),a("blockquote",[a("p",[t._v("首先注意，Socket 不是 Java 中独有的概念，而是一个语言无关标准。任何可以实现网络编程的编程语言都有 Socket。")])]),t._v(" "),a("h4",{attrs:{id:"socket"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#socket"}},[t._v("#")]),t._v(" Socket")]),t._v(" "),a("p",[t._v("网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。")]),t._v(" "),a("p",[t._v("建立网络通信连接至少要一个"),a("strong",[t._v("端口号")]),t._v("。socket 本质是编程接口(API)，对 "),a("strong",[t._v("TCP/IP")]),t._v(" 的封装，TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口")]),t._v(" "),a("p",[t._v('HTTP 是轿车，提供了封装或者显示数据的具体形式；Socket 是发动机，提供了网络通信的能力。Socket 的英文原义是“孔”或“插座”。作为 BSD UNIX 的进程通信机制，取后一种意思。通常也称作"套接字"，用于描述 IP 地址和端口，是一个通信链的句柄，可以用来实现不同虚拟机或不同计算机之间的通信。在Internet 上的主机一般运行了多个服务软件，同时提供几种服务。每种服务都打开一个 Socket，并绑定到一个端口上，不同的端口对应于不同的服务。Socket 正如其英文原义那样，像一个多孔插座。一台主机犹如布满各种插座的房间，每个插座有一个编号，有的插座提供 220 伏交流电， 有的提供 110 伏交流电，有的则提供有线电视节目。 客户软件将插头插到不同编号的插座，就可以得到不同的服务。')]),t._v(" "),a("h4",{attrs:{id:"socket-连接步骤"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#socket-连接步骤"}},[t._v("#")]),t._v(" Socket 连接步骤")]),t._v(" "),a("p",[t._v("根据连接启动的方式以及本地套接字要连接的目标，套接字之间的连接过程可以分为三个步骤："),a("strong",[t._v("服务器监听")]),t._v("，"),a("strong",[t._v("客户端请求")]),t._v("，"),a("strong",[t._v("连接确认")]),t._v("。【如果包含"),a("strong",[t._v("数据交互")]),t._v("+"),a("strong",[t._v("断开连接")]),t._v("，那么一共是五个步骤】")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("服务器监听：是服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态。")])]),t._v(" "),a("li",[a("p",[t._v("客户端请求：是指由客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。")])]),t._v(" "),a("li",[a("p",[t._v("连接确认：是指当服务器端套接字监听到或者说接收到客户端套接字的连接请求，它就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，连接就建立好了。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。\n"),a("img",{attrs:{src:"https://alightyoung.gitee.io/static/img/25.png",alt:"img"}})])])]),t._v(" "),a("h4",{attrs:{id:"java-中的-socket"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java-中的-socket"}},[t._v("#")]),t._v(" Java 中的 Socket")]),t._v(" "),a("p",[t._v("在 java.net 包是网络编程的基础类库。其中 ServerSocket 和 Socket 是网络编程的基础类型。ServerSocket 是服务端应用类型。Socket 是建立连接的类型。当连接建立成功后，服务器和客户端都会有一个 Socket 对象示例，可以通过这个 Socket 对象示例，完成会话的所有操作。对于一个完整的网络连接来说，Socket 是平等的，没有服务器客户端分级情况。")]),t._v(" "),a("h3",{attrs:{id:"同步-异步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#同步-异步"}},[t._v("#")]),t._v(" 同步&异步")]),t._v(" "),a("p",[t._v("同步和异步是针对应用程序和内核的交互而言的，同步指的是用户进程触发 IO 操作并等待或者轮询的去看 IO 操作是否就绪，而异步是指用户进程触发 IO 操作以后便开始做自己的事情，而当 IO 操作已经完成的时候会得到 IO 完成的通知。以银行取款为例：")]),t._v(" "),a("p",[t._v("同步 ： 自己亲自出马持银行卡到银行取钱（使用同步 IO 时，Java 自己处理 IO 读写）")]),t._v(" "),a("p",[t._v("异步 ： 委托一小弟拿银行卡到银行取钱，然后给你（使用异步 IO 时，Java 将 IO 读写委托给 OS 处理，需要将数据缓冲区地址和大小传给 OS(银行卡和密码)，OS 需要支持异步 IO操作 API）。")]),t._v(" "),a("h3",{attrs:{id:"阻塞-非阻塞"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#阻塞-非阻塞"}},[t._v("#")]),t._v(" 阻塞&非阻塞")]),t._v(" "),a("p",[t._v("阻塞和非阻塞是针对于进程在访问数据的时候，根据 IO 操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作方法的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入方法会立即返回一个状态值。以银行取款为例：阻塞 ： ATM 排队取款，你只能等待（使用阻塞 IO 时，Java 调用会一直阻塞到读写完成才返回）；非阻塞 ： 柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理，没到号你就不能去，你可以不断问大堂经理排到了没有，大堂经理如果说还没到你就不能去（使用非阻塞 IO 时，如果不能读写 Java 调用会马上返回，当 IO 事件分发器通知可读写时再继续进行读写，不断循环直到读写完成）。")]),t._v(" "),a("h3",{attrs:{id:"bio-编程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bio-编程"}},[t._v("#")]),t._v(" BIO 编程")]),t._v(" "),a("p",[t._v("Blocking IO： 同步阻塞的编程方式。")]),t._v(" "),a("p",[t._v("BIO 编程方式通常是在 JDK1.4 版本之前常用的编程方式。编程实现过程为：首先在服务端启动一个 ServerSocket 来监听网络请求，客户端启动 Socket 发起网络请求，默认情况下ServerSocket 会建立一个线程来处理此请求，如果服务端没有线程可用，客户端则会阻塞等待或遭到拒绝。且已经建立好的连接，在通讯过程中，是同步的。在并发处理效率上比较低。大致结构如下：\n"),a("img",{attrs:{src:"https://alightyoung.gitee.io/static/img/26.png",alt:"img"}}),t._v("\n同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。")]),t._v(" "),a("p",[t._v("BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，但程序直观简单易理解。")]),t._v(" "),a("p",[t._v("使用线程池机制改善后的 BIO 模型图如下:\n"),a("img",{attrs:{src:"https://alightyoung.gitee.io/static/img/27.png",alt:"img"}})]),t._v(" "),a("h3",{attrs:{id:"nio-编程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nio-编程"}},[t._v("#")]),t._v(" NIO 编程")]),t._v(" "),a("p",[t._v("Unblocking IO（New IO）： 同步非阻塞的编程方式。")]),t._v(" "),a("p",[t._v("NIO 本身是基于事件驱动思想来完成的，其主要想解决的是 BIO 的大并发问题，NIO 基于 Reactor，当 socket 有流可读或可写入 socket 时，操作系统会相应的通知引用程序进行处理，应用再将流读取到缓冲区或写入操作系统。也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。")]),t._v(" "),a("p",[t._v("NIO 的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被注册到多路复用器上面，所以所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求一个线程模式。")]),t._v(" "),a("p",[t._v("在 NIO 的处理方式中，当一个请求来的话，开启线程进行处理，可能会等待后端应用的资源(JDBC 连接等)，其实这个线程就被阻塞了，当并发上来的话，还是会有 BIO 一样的问题。\n"),a("img",{attrs:{src:"https://alightyoung.gitee.io/static/img/28.png",alt:"img"}})]),t._v(" "),a("p",[t._v("同步非阻塞，服务器实现模式为一个请求一个通道，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 I/O 请求时才启动一个线程进行处理。")]),t._v(" "),a("p",[t._v("NIO 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程复杂，JDK1.4 开始支持。")]),t._v(" "),a("h3",{attrs:{id:"aio-编程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aio-编程"}},[t._v("#")]),t._v(" AIO 编程")]),t._v(" "),a("p",[t._v("AsynchronousIO： 异步非阻塞的编程方式")]),t._v(" "),a("p",[t._v("与 NIO 不同，当进行读写操作时，只须直接调用 API 的 read 或 write 方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入 read 方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将 write 方法传递的流写入完毕时，操作系统主动通知应用程序。即可以理解为，read/write 方法都是异步的，完成后会主动调用回调函数。在 JDK1.7 中，这部分内容被称作 NIO.2，主要在 java.nio.channels 包下增加了下面四个异步通道：")]),t._v(" "),a("ul",[a("li",[t._v("AsynchronousSocketChannel")]),t._v(" "),a("li",[t._v("AsynchronousServerSocketChannel")]),t._v(" "),a("li",[t._v("AsynchronousFileChannel")]),t._v(" "),a("li",[t._v("AsynchronousDatagramChannel")])]),t._v(" "),a("p",[t._v("异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的 I/O 请求都是由 OS先完成了再通知服务器应用去启动线程进行处理")]),t._v(" "),a("p",[t._v("AIO 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂，JDK7 开始支持。")])])}),[],!1,null,null,null);a.default=_.exports}}]);